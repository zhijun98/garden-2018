/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package com.zcomapproach.garden.peony.admin.zcadocmaster;

import com.zcomapproach.garden.peony.PeonyLauncher;
import com.zcomapproach.garden.peony.admin.zcadocmaster.events.IZcaDocMessageEvent;
import com.zcomapproach.garden.peony.admin.zcadocmaster.events.IZcaDocSwingWorkerEvent;
import com.zcomapproach.garden.peony.admin.zcadocmaster.exceptions.ZcaDocWorkerNotReadyException;
import com.zcomapproach.garden.peony.admin.zcadocmaster.face.IZcaDocTaskOwner;
import com.zcomapproach.garden.peony.admin.zcadocmaster.face.TaskCreationDialog;
import com.zcomapproach.garden.peony.admin.zcadocmaster.face.worker.ZcaDocSwingWorkerManager;
import com.zcomapproach.garden.peony.admin.zcadocmaster.face.worker.ZcaDocTask;
import com.zcomapproach.garden.peony.utils.PeonyFaceUtils;
import com.zcomapproach.zcaglobals.commons.ZCalendarGlobal;
import com.zcomapproach.zcaglobals.commons.ZPlatformGlobal;
import com.zcomapproach.zcaglobals.commons.ZSwingGlobal;
import com.zcomapproach.zcaglobals.debug.ZLogFileHandler;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.InputEvent;
import java.awt.event.ItemEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.GregorianCalendar;
import java.util.List;
import javax.swing.JButton;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPopupMenu;
import javax.swing.JTree;
import javax.swing.SwingUtilities;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.TreeNode;
import javax.swing.tree.TreePath;
import org.openide.awt.ActionID;
import org.openide.awt.ActionReference;
import org.openide.windows.TopComponent;
import org.openide.util.NbBundle.Messages;

/**
 * Top component which displays something.
 */
@TopComponent.Description(
        preferredID = "DocMasterTopComponent",
        iconBase = "com/zcomapproach/garden/peony/resources/images/folder_database.png",
        persistenceType = TopComponent.PERSISTENCE_NEVER
)
@TopComponent.Registration(mode = "editor", openAtStartup = false)
@ActionID(category = "Window", id = "com.zcomapproach.garden.peony.admin.zcadocmaster.DocMasterTopComponent")
@ActionReference(path = "Menu/Window" /*, position = 333 */)
@TopComponent.OpenActionRegistration(
        displayName = "#CTL_DocMasterAction",
        preferredID = "DocMasterTopComponent"
)
@Messages({
    "CTL_DocMasterAction=DocMaster",
    "CTL_DocMasterTopComponent=DocMaster Window",
    "HINT_DocMasterTopComponent=This is a DocMaster window"
})
public final class DocMasterTopComponent extends TopComponent implements IZcaDocTaskOwner{
    
    /**
     * root and its jTaskTree need to be synchronized by "this" object
     */
    private DefaultMutableTreeNode scheduledRoot;
    private DefaultMutableTreeNode oneTimeRoot;

    private final int StatusMonitorThreshold = 1000;
    private int statusMonitor = 0;
    
    private int lastIndexOfPersistentTask;

    private ZcaDocFrameProperties prop;
    
    private TaskCreationDialog aTaskCreationDialog;

    public DocMasterTopComponent() {
        initComponents();
        setName(Bundle.CTL_DocMasterTopComponent());
        setToolTipText(Bundle.HINT_DocMasterTopComponent());
        
        initializeTaskTree();

    }

    private TaskCreationDialog getTaskCreationDialog(){
        if (aTaskCreationDialog == null){
            aTaskCreationDialog = new TaskCreationDialog(null, true, this);
            aTaskCreationDialog.pack();
            aTaskCreationDialog.setLocation(ZSwingGlobal.getScreenCenterPoint(aTaskCreationDialog));
        }
        return aTaskCreationDialog;
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jLabel1 = new javax.swing.JLabel();
        jPanel1 = new javax.swing.JPanel();
        jCreateBackupTask = new javax.swing.JButton();
        jExecuteSelectedTasks = new javax.swing.JButton();
        jExecuteAllTasks = new javax.swing.JButton();
        jValidateTaskList = new javax.swing.JButton();
        jCancelTasks = new javax.swing.JButton();
        jCleanStatusReport = new javax.swing.JButton();
        jRefreshTree = new javax.swing.JButton();
        jScrollPane2 = new javax.swing.JScrollPane();
        jStatus = new javax.swing.JTextArea();
        jLogging = new javax.swing.JCheckBox();
        jRunTasksAtSchedule = new javax.swing.JCheckBox();
        jTabbedPane1 = new javax.swing.JTabbedPane();
        jScrollPane1 = new javax.swing.JScrollPane();
        jScheduledTaskTree = new javax.swing.JTree();
        jScrollPane3 = new javax.swing.JScrollPane();
        jOneTimeTaskTree = new javax.swing.JTree();
        jArchive = new javax.swing.JButton();

        setMinimumSize(new java.awt.Dimension(800, 600));

        org.openide.awt.Mnemonics.setLocalizedText(jLabel1, org.openide.util.NbBundle.getMessage(DocMasterTopComponent.class, "DocMasterTopComponent.jLabel1.text")); // NOI18N

        jPanel1.setLayout(new java.awt.GridLayout(1, 0, 2, 0));

        org.openide.awt.Mnemonics.setLocalizedText(jCreateBackupTask, org.openide.util.NbBundle.getMessage(DocMasterTopComponent.class, "DocMasterTopComponent.jCreateBackupTask.text")); // NOI18N
        jCreateBackupTask.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCreateBackupTaskActionPerformed(evt);
            }
        });
        jPanel1.add(jCreateBackupTask);

        org.openide.awt.Mnemonics.setLocalizedText(jExecuteSelectedTasks, org.openide.util.NbBundle.getMessage(DocMasterTopComponent.class, "DocMasterTopComponent.jExecuteSelectedTasks.text")); // NOI18N
        jExecuteSelectedTasks.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jExecuteSelectedTasksActionPerformed(evt);
            }
        });
        jPanel1.add(jExecuteSelectedTasks);

        org.openide.awt.Mnemonics.setLocalizedText(jExecuteAllTasks, org.openide.util.NbBundle.getMessage(DocMasterTopComponent.class, "DocMasterTopComponent.jExecuteAllTasks.text")); // NOI18N
        jExecuteAllTasks.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jExecuteAllTasksActionPerformed(evt);
            }
        });
        jPanel1.add(jExecuteAllTasks);

        org.openide.awt.Mnemonics.setLocalizedText(jValidateTaskList, org.openide.util.NbBundle.getMessage(DocMasterTopComponent.class, "DocMasterTopComponent.jValidateTaskList.text")); // NOI18N
        jValidateTaskList.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jValidateTaskListActionPerformed(evt);
            }
        });
        jPanel1.add(jValidateTaskList);

        jCancelTasks.setForeground(new java.awt.Color(255, 0, 0));
        org.openide.awt.Mnemonics.setLocalizedText(jCancelTasks, org.openide.util.NbBundle.getMessage(DocMasterTopComponent.class, "DocMasterTopComponent.jCancelTasks.text")); // NOI18N
        jCancelTasks.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCancelTasksActionPerformed(evt);
            }
        });
        jPanel1.add(jCancelTasks);

        jCleanStatusReport.setForeground(new java.awt.Color(0, 102, 0));
        org.openide.awt.Mnemonics.setLocalizedText(jCleanStatusReport, org.openide.util.NbBundle.getMessage(DocMasterTopComponent.class, "DocMasterTopComponent.jCleanStatusReport.text")); // NOI18N
        jCleanStatusReport.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCleanStatusReportActionPerformed(evt);
            }
        });
        jPanel1.add(jCleanStatusReport);

        jRefreshTree.setForeground(new java.awt.Color(0, 0, 255));
        org.openide.awt.Mnemonics.setLocalizedText(jRefreshTree, org.openide.util.NbBundle.getMessage(DocMasterTopComponent.class, "DocMasterTopComponent.jRefreshTree.text")); // NOI18N
        jRefreshTree.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jRefreshTreeActionPerformed(evt);
            }
        });
        jPanel1.add(jRefreshTree);

        jScrollPane2.setCursor(new java.awt.Cursor(java.awt.Cursor.DEFAULT_CURSOR));

        jStatus.setColumns(20);
        jStatus.setLineWrap(true);
        jStatus.setRows(5);
        jStatus.setWrapStyleWord(true);
        jStatus.setAutoscrolls(false);
        jStatus.setBorder(javax.swing.BorderFactory.createEtchedBorder());
        jScrollPane2.setViewportView(jStatus);

        org.openide.awt.Mnemonics.setLocalizedText(jLogging, org.openide.util.NbBundle.getMessage(DocMasterTopComponent.class, "DocMasterTopComponent.jLogging.text")); // NOI18N
        jLogging.setHorizontalTextPosition(javax.swing.SwingConstants.LEFT);

        jRunTasksAtSchedule.setSelected(true);
        org.openide.awt.Mnemonics.setLocalizedText(jRunTasksAtSchedule, org.openide.util.NbBundle.getMessage(DocMasterTopComponent.class, "DocMasterTopComponent.jRunTasksAtSchedule.text")); // NOI18N
        jRunTasksAtSchedule.setHorizontalTextPosition(javax.swing.SwingConstants.LEFT);
        jRunTasksAtSchedule.addItemListener(new java.awt.event.ItemListener() {
            public void itemStateChanged(java.awt.event.ItemEvent evt) {
                jRunTasksAtScheduleItemStateChanged(evt);
            }
        });

        jScrollPane1.setAutoscrolls(true);

        jScheduledTaskTree.setAutoscrolls(true);
        jScrollPane1.setViewportView(jScheduledTaskTree);

        jTabbedPane1.addTab(org.openide.util.NbBundle.getMessage(DocMasterTopComponent.class, "DocMasterTopComponent.jScrollPane1.TabConstraints.tabTitle"), jScrollPane1); // NOI18N

        jScrollPane3.setViewportView(jOneTimeTaskTree);

        jTabbedPane1.addTab(org.openide.util.NbBundle.getMessage(DocMasterTopComponent.class, "DocMasterTopComponent.jScrollPane3.TabConstraints.tabTitle"), jScrollPane3); // NOI18N

        org.openide.awt.Mnemonics.setLocalizedText(jArchive, org.openide.util.NbBundle.getMessage(DocMasterTopComponent.class, "DocMasterTopComponent.jArchive.text")); // NOI18N
        jArchive.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jArchiveActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(jScrollPane2))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(10, 10, 10)
                        .addComponent(jLabel1)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(jArchive)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(jLogging)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(jRunTasksAtSchedule))
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(0, 75, Short.MAX_VALUE))
                    .addComponent(jTabbedPane1, javax.swing.GroupLayout.Alignment.TRAILING))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel1)
                    .addComponent(jRunTasksAtSchedule)
                    .addComponent(jLogging)
                    .addComponent(jArchive))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jTabbedPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 322, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jScrollPane2, javax.swing.GroupLayout.DEFAULT_SIZE, 182, Short.MAX_VALUE)
                .addContainerGap())
        );
    }// </editor-fold>//GEN-END:initComponents

    private void jCreateBackupTaskActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCreateBackupTaskActionPerformed
        getTaskCreationDialog().setVisible(true);
    }//GEN-LAST:event_jCreateBackupTaskActionPerformed

    private void jExecuteSelectedTasksActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jExecuteSelectedTasksActionPerformed
        if (PeonyFaceUtils.displayConfirmDialog(PeonyLauncher.mainFrame, "Are you sure ONLY to execute the selected task in the task list?") == JOptionPane.YES_OPTION){
            executeTasksHelper(jExecuteSelectedTasks, retrieveSelectedZcaDocTaskList());
        }
    }//GEN-LAST:event_jExecuteSelectedTasksActionPerformed

    private void jExecuteAllTasksActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jExecuteAllTasksActionPerformed
        if (PeonyFaceUtils.displayConfirmDialog(PeonyLauncher.mainFrame, "Are you sure to execute ALL the tasks in the list?") == JOptionPane.YES_OPTION){
            executeTasksHelper(jExecuteAllTasks, retrieveAllZcaDocTaskList());
        }
    }//GEN-LAST:event_jExecuteAllTasksActionPerformed

    private void jValidateTaskListActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jValidateTaskListActionPerformed
        jValidateTaskList.setEnabled(false);
        try{
            (ZcaDocSwingWorkerManager.getSingleton().getZcaDocValidationWorker(retrieveAllZcaDocTaskList(), this)).execute();
        }catch (ZcaDocWorkerNotReadyException ex){
            JOptionPane.showMessageDialog(this, ex.getMessage());
            jValidateTaskList.setEnabled(true);
        }
    }//GEN-LAST:event_jValidateTaskListActionPerformed

    private void jCancelTasksActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCancelTasksActionPerformed
        if (JOptionPane.showConfirmDialog(this, "Cancel current running tasks?") == JOptionPane.YES_OPTION){
            ZcaDocSwingWorkerManager.getSingleton().cancelCurrentWorker();
        }
    }//GEN-LAST:event_jCancelTasksActionPerformed

    private void jCleanStatusReportActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCleanStatusReportActionPerformed
        jStatus.setText("");
    }//GEN-LAST:event_jCleanStatusReportActionPerformed

    private void jRefreshTreeActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jRefreshTreeActionPerformed
        saveAndRefreshTasks();
    }//GEN-LAST:event_jRefreshTreeActionPerformed

    private void jRunTasksAtScheduleItemStateChanged(java.awt.event.ItemEvent evt) {//GEN-FIRST:event_jRunTasksAtScheduleItemStateChanged
        if (evt.getStateChange() == ItemEvent.DESELECTED){
            ZcaDocSwingWorkerManager.getSingleton().stopBackupScheduler(this);
        }
        if (evt.getStateChange() == ItemEvent.SELECTED){
            ZcaDocSwingWorkerManager.getSingleton().startBackupScheduler(this);
        }
    }//GEN-LAST:event_jRunTasksAtScheduleItemStateChanged

    private void jArchiveActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jArchiveActionPerformed
        if (PeonyFaceUtils.displayConfirmDialog(PeonyLauncher.mainFrame, "Are you sure to archive documents and files for Peony? This is time-consuming and will be running in the background.") == JOptionPane.YES_OPTION){
            refactorArchive09282019();
        }
    }//GEN-LAST:event_jArchiveActionPerformed

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jArchive;
    private javax.swing.JButton jCancelTasks;
    private javax.swing.JButton jCleanStatusReport;
    private javax.swing.JButton jCreateBackupTask;
    private javax.swing.JButton jExecuteAllTasks;
    private javax.swing.JButton jExecuteSelectedTasks;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JCheckBox jLogging;
    private javax.swing.JTree jOneTimeTaskTree;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JButton jRefreshTree;
    private javax.swing.JCheckBox jRunTasksAtSchedule;
    private javax.swing.JTree jScheduledTaskTree;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JTextArea jStatus;
    private javax.swing.JTabbedPane jTabbedPane1;
    private javax.swing.JButton jValidateTaskList;
    // End of variables declaration//GEN-END:variables
    @Override
    public void componentOpened() {
        if (jRunTasksAtSchedule.isSelected()){
            ZcaDocSwingWorkerManager.getSingleton().startBackupScheduler(this);
        }
    }

    @Override
    public void componentClosed() {
        ZcaDocSwingWorkerManager.getSingleton().stopBackupScheduler(this);
    }
    
    @Override
    public void swingWorkerDoneEventHappened(final IZcaDocSwingWorkerEvent event) {
        if (SwingUtilities.isEventDispatchThread()){
            swingWorkerDoneEventHappenedHelper(event);
        }else{
            SwingUtilities.invokeLater(new Runnable(){
                @Override
                public void run() {
                    swingWorkerDoneEventHappenedHelper(event);
                }
            });
        }
    }
    private void swingWorkerDoneEventHappenedHelper(final IZcaDocSwingWorkerEvent event) {
        jExecuteSelectedTasks.setEnabled(true);
        jExecuteAllTasks.setEnabled(true);
        jValidateTaskList.setEnabled(true);
    }
    private synchronized void expandTaskTree(JTree jTree) {
        for (int i = 0; i < jTree.getRowCount(); i++) {
            jTree.expandPath(jTree.getPathForRow(i));
        }
    }

    @Override
    public synchronized List<ZcaDocTask> retrieveDuedTaskList() {
        ArrayList<ZcaDocTask> aZcaDocTaskList = new ArrayList<>();
        int total = scheduledRoot.getChildCount();
        TreeNode treeNode;
        Object task;
        ZcaDocTask aZcaDocTask;
        GregorianCalendar currentTimePoint = new GregorianCalendar();
        GregorianCalendar taskTimePoint;
        for (int i = 0; i < total; i++){
            treeNode = scheduledRoot.getChildAt(i);
            if (treeNode instanceof DefaultMutableTreeNode){
                task = ((DefaultMutableTreeNode)treeNode).getUserObject();
                if (task instanceof ZcaDocTask){
                    aZcaDocTask = (ZcaDocTask)task;
                    taskTimePoint = aZcaDocTask.getDueTimePoint();
                    if ((taskTimePoint != null) && (currentTimePoint.after(taskTimePoint))){
                        aZcaDocTaskList.add(aZcaDocTask);
                    }
                }
            }
        }//for
        return aZcaDocTaskList;
    }

    private synchronized List<ZcaDocTask> retrieveAllZcaDocTaskList() {
        List<ZcaDocTask> aZcaDocTaskList = retrieveAllZcaDocTaskListHelper(scheduledRoot);
        aZcaDocTaskList.addAll(retrieveAllZcaDocTaskListHelper(oneTimeRoot));
        return aZcaDocTaskList;
    }

    private synchronized List<ZcaDocTask> retrieveAllZcaDocTaskListHelper(DefaultMutableTreeNode root) {
        ArrayList<ZcaDocTask> aZcaDocTaskList = new ArrayList<>();
        int total = root.getChildCount();
        TreeNode treeNode;
        Object task;
        for (int i = 0; i < total; i++){
            treeNode = root.getChildAt(i);
            if (treeNode instanceof DefaultMutableTreeNode){
                task = ((DefaultMutableTreeNode)treeNode).getUserObject();
                if (task instanceof ZcaDocTask){
                    aZcaDocTaskList.add((ZcaDocTask)task);
                }
            }
        }//for
        return aZcaDocTaskList;
    }

    private synchronized List<ZcaDocTask> retrieveSelectedZcaDocTaskList() {
        List<ZcaDocTask> aZcaDocTaskList = retrieveSelectedZcaDocTaskListHelper(jScheduledTaskTree);
        aZcaDocTaskList.addAll(retrieveSelectedZcaDocTaskListHelper(jOneTimeTaskTree));
        return aZcaDocTaskList;
    }

    private synchronized List<ZcaDocTask> retrieveSelectedZcaDocTaskListHelper(JTree jTree) {
        ArrayList<ZcaDocTask> aZcaDocTaskList = new ArrayList<>();
        TreePath[] aSelectedTreePathArray = jTree.getSelectionPaths();
        if (aSelectedTreePathArray != null){
            TreeNode treeNode;
            Object task;
            for (TreePath aTreePath : aSelectedTreePathArray){
                treeNode = (TreeNode)aTreePath.getLastPathComponent();
                if (treeNode instanceof DefaultMutableTreeNode){
                    task = ((DefaultMutableTreeNode)treeNode).getUserObject();
                    if (task instanceof ZcaDocTask){
                        aZcaDocTaskList.add((ZcaDocTask)task);
                    }
                }
            }
        }
        return aZcaDocTaskList;
    }

    public synchronized void addZcaDocTask(ZcaDocTask aZcaDocTask) {
        addZcaDocTaskNode(aZcaDocTask);
    }

    private synchronized void addZcaDocTaskNode(ZcaDocTask aZcaDocTask) {
        if (aZcaDocTask != null){
            DefaultMutableTreeNode sourceNode = new DefaultMutableTreeNode(aZcaDocTask);
            DefaultMutableTreeNode backupNode;
            if (aZcaDocTask.isBackupPathSuffixRequired()){
                backupNode = new DefaultMutableTreeNode("Backup to: " + aZcaDocTask.getBackupPath() + "_MMddyyyyHHmmss");
            }else{
                backupNode = new DefaultMutableTreeNode("Backup to: " + aZcaDocTask.getBackupPath());
            }
            DefaultMutableTreeNode overwriteNode;
            if (aZcaDocTask.isOverwriteRequired()){
                overwriteNode = new DefaultMutableTreeNode("Overwrite: YES");
            }else{
                overwriteNode = new DefaultMutableTreeNode("Overwrite: NO");
            }
            DefaultMutableTreeNode runNode;
            DefaultMutableTreeNode scheduleNode;
            GregorianCalendar timePoint = aZcaDocTask.getDueTimePoint();
            if (timePoint == null){
                runNode = new DefaultMutableTreeNode("Next Run: manual mode");
                scheduleNode = new DefaultMutableTreeNode("This task was not Scheduled for any week-day.");
            }else{
                runNode = new DefaultMutableTreeNode("Next Run: automatically run at " 
                        + ZCalendarGlobal.convertToMMddyyyyHHmmss(timePoint, "-", "@", ":"));
                scheduleNode = new DefaultMutableTreeNode("Scheduled at: " + aZcaDocTask.getScheduledDayOfWeekDescription());
            }
            sourceNode.add(backupNode);
            sourceNode.add(overwriteNode);
            sourceNode.add(runNode);
            sourceNode.add(scheduleNode);
            if (timePoint == null){
                oneTimeRoot.add(sourceNode);
                jOneTimeTaskTree.updateUI();
                expandTaskTree(jOneTimeTaskTree);
            }else{
                scheduledRoot.add(sourceNode);
                jScheduledTaskTree.updateUI();
                expandTaskTree(jScheduledTaskTree);
            }
        }
    }
    
    private synchronized void buildTaskTreeModel() {
        prop = new ZcaDocFrameProperties("ZcaDocMaster");
        scheduledRoot = new DefaultMutableTreeNode("Scheduled Task List");
        oneTimeRoot = new DefaultMutableTreeNode("One-Time Task List");
        ZcaDocTask aZcaDocTask;
        lastIndexOfPersistentTask = 0;
        while (true){
            aZcaDocTask = prop.getZcaDocTask(lastIndexOfPersistentTask);
            if (aZcaDocTask == null){
                break;
            }else{
                addZcaDocTaskNode(aZcaDocTask);
            }
            lastIndexOfPersistentTask++;
        }
        
        jScheduledTaskTree.setModel(new DefaultTreeModel(scheduledRoot));
        jOneTimeTaskTree.setModel(new DefaultTreeModel(oneTimeRoot));
    }

    /**
     * This should be invoked in the constructor
     */
    private synchronized void initializeTaskTree() {
        
        buildTaskTreeModel();
        
        initializeTaskTreeShortCutMenu(jScheduledTaskTree);
        initializeTaskTreeShortCutMenu(jOneTimeTaskTree);
    }
    
    private void initializeTaskTreeShortCutMenu(final JTree jTree){
        
        jTree.addMouseListener(new MouseAdapter() {
            @Override
            public void mousePressed(MouseEvent event) {
                if (((event.getModifiers() & InputEvent.BUTTON3_MASK) != 0)
                    && (jTree.getSelectionCount() > 0)) {
                    showMenu(event.getX(), event.getY());
                }
            }

            private void showMenu(int x, int y) {
                JPopupMenu popup = new JPopupMenu();
                JMenuItem mi = new JMenuItem("Delete");
                TreePath path = jTree.getSelectionPath();
                if ((path == null) || (path.getPathCount() != 2)){
                    return;
                }
                Object node = path.getLastPathComponent();
                if (node == jTree.getModel().getRoot()) {
                    mi.setEnabled(false);
                }
                popup.add(mi);
                mi.addActionListener(new ActionListener() {
                    @Override
                    public void actionPerformed(ActionEvent event) {
                        deleteSelectedItems();
                    }
                });
                popup.show(jTree, x, y);
            }

            private void deleteSelectedItems() {
                DefaultMutableTreeNode node;
                DefaultTreeModel model = (DefaultTreeModel) (jTree.getModel());
                TreePath[] paths = jTree.getSelectionPaths();
                for (TreePath path : paths) {
                    if (path.getPathCount() == 2){
                        node = (DefaultMutableTreeNode) (path.getLastPathComponent());
                        model.removeNodeFromParent(node);
                    }
                }
            }
        });
    
    }
    
    @Override
    public void statusMessagingEventHappened(IZcaDocMessageEvent event) {
        String msg = event.getEventMessage();
        jStatus.insert(msg + ZPlatformGlobal.lineSeparator(), jStatus.getDocument().getLength());
        if (event.isLoggingRequired()){
            ZLogFileHandler.getSingleton().publish(ZLogFileHandler.createInfoLogRecord(msg));
        }
        /**
         * clear the status control for performance
         */
        statusMonitor++;
        if (statusMonitor > StatusMonitorThreshold){
            jStatus.setText("");
            statusMonitor = 0;
        }
    }

    public void saveAndRefreshTasks() {
        if (SwingUtilities.isEventDispatchThread()){
            saveAndRefreshTasksHelper();
        }else{
            SwingUtilities.invokeLater(new Runnable(){
                @Override
                public void run() {
                    saveAndRefreshTasksHelper();
                }
            });
        }
    }
    
    private void saveAndRefreshTasksHelper() {
        prop.removeZcaDocTaskList(lastIndexOfPersistentTask);
        prop.saveZcaDocTaskList(retrieveAllZcaDocTaskList());
        buildTaskTreeModel();
    }

    private void executeTasksHelper(JButton executeTasksButton, List<ZcaDocTask> zcaDocTaskList) {
        executeTasksButton.setEnabled(false);
        try{
            (ZcaDocSwingWorkerManager.getSingleton().getZcaDocBackupWorker(zcaDocTaskList, this)).execute();
        }catch (ZcaDocWorkerNotReadyException ex){
            JOptionPane.showMessageDialog(this, ex.getMessage());
            executeTasksButton.setEnabled(true);
        }
    }

    /**
     * This is how to refactor Peony's archive system: (09-28-2019)
     * 
     * (1) g02_archived_file will not use of the field "file_path" anymore. The 
     * archived file's location will be encoded in the Peony implementation. (after 
     * everything done, the column can be dropped.)
     * (2) transfer all the g02_archived_document's records, which recorded 2018 
     * tax season's uploaded files, into g02_archived_file (done in the RoseWeb 
     * project)
     * (3) download all the physical files of g02_archived_document from RoseWeb 
     * into the local archive root folder without any subfolder. (done in this method)
     * (4) copy all the files, which were recorded by file_path in the g02_archived_file, 
     * into the archive root folder. MEANWHILE, upload them onto RoseWeb server. 
     * (done in this method)
     * (5) refactor the implementation to avoid using of g02_archived_file's file_path. 
     * And also, whenever archive a new file, Peony not only archives it locally 
     * but also upload it to RoseWeb server. 
     * (6) after run this in the Lu-Yin's office, change this button's privilege 
     * that is only authorized to GardenMaster and the implementation so as to backup 
     * the archived files from RoseWeb at the local development environment automatically 
     * based on the schedule.
     */
    private void refactorArchive09282019() {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

}
