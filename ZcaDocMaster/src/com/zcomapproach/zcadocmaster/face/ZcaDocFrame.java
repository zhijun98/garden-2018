/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

package com.zcomapproach.zcadocmaster.face;

import com.zcomapproach.zcadocmaster.ZcaDocFrameProperties;
import com.zcomapproach.zcadocmaster.events.IZcaDocMessageEvent;
import com.zcomapproach.zcadocmaster.events.IZcaDocSwingWorkerEvent;
import com.zcomapproach.zcadocmaster.exceptions.ZcaDocWorkerNotReadyException;
import com.zcomapproach.zcadocmaster.face.worker.ZcaDocTask;
import com.zcomapproach.zcadocmaster.face.worker.ZcaDocSwingWorkerManager;
import com.zcomapproach.zcaglobals.commons.ZCalendarGlobal;
import com.zcomapproach.zcaglobals.commons.ZPlatformGlobal;
import com.zcomapproach.zcaglobals.commons.ZSwingGlobal;
import com.zcomapproach.zcaglobals.debug.ZLogFileHandler;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.InputEvent;
import java.awt.event.ItemEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.GregorianCalendar;
import java.util.List;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPopupMenu;
import javax.swing.JTree;
import javax.swing.SwingUtilities;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.TreeNode;
import javax.swing.tree.TreePath;

/**
 *
 * @author Zhijun Zhang
 */
public class ZcaDocFrame extends javax.swing.JFrame implements IZcaDocTaskOwner{
    
    /**
     * root and its jTaskTree need to be synchronized by "this" object
     */
    private DefaultMutableTreeNode scheduledRoot;
    private DefaultMutableTreeNode oneTimeRoot;

    private final int StatusMonitorThreshold = 1000;
    private int statusMonitor = 0;
    
    private int lastIndexOfPersistentTask;

    private ZcaDocFrameProperties prop;
    
    private TaskCreationDialog aTaskCreationDialog;
    
    /**
     * Creates new form ZcaDocFrame
     */
    public ZcaDocFrame() {
        
        initComponents();
        
        initializeTaskTree();
    }

    @Override
    public void setVisible(boolean visible) {
        if (visible){
            if (jRunTasksAtSchedule.isSelected()){
                ZcaDocSwingWorkerManager.getSingleton().startBackupScheduler(this);
            }
        }
        super.setVisible(visible); //To change body of generated methods, choose Tools | Templates.
    }

    private TaskCreationDialog getTaskCreationDialog(){
        if (aTaskCreationDialog == null){
            aTaskCreationDialog = new TaskCreationDialog(this, true);
            aTaskCreationDialog.pack();
            aTaskCreationDialog.setLocation(ZSwingGlobal.getScreenCenterPoint(aTaskCreationDialog));
        }
        return aTaskCreationDialog;
    }
    
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jLabel1 = new javax.swing.JLabel();
        jPanel1 = new javax.swing.JPanel();
        jCreateBackupTask = new javax.swing.JButton();
        jExecuteSelectedTasks = new javax.swing.JButton();
        jExecuteAllTasks = new javax.swing.JButton();
        jValidateTaskList = new javax.swing.JButton();
        jCancelTasks = new javax.swing.JButton();
        jCleanStatusReport = new javax.swing.JButton();
        jRefreshTree = new javax.swing.JButton();
        jScrollPane2 = new javax.swing.JScrollPane();
        jStatus = new javax.swing.JTextArea();
        jLogging = new javax.swing.JCheckBox();
        jRunTasksAtSchedule = new javax.swing.JCheckBox();
        jTabbedPane1 = new javax.swing.JTabbedPane();
        jScrollPane1 = new javax.swing.JScrollPane();
        jScheduledTaskTree = new javax.swing.JTree();
        jScrollPane3 = new javax.swing.JScrollPane();
        jOneTimeTaskTree = new javax.swing.JTree();

        setDefaultCloseOperation(javax.swing.WindowConstants.DO_NOTHING_ON_CLOSE);
        setTitle("ZCA Doc-Master");
        setMinimumSize(new java.awt.Dimension(800, 600));
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent evt) {
                formWindowClosing(evt);
            }
        });

        jLabel1.setText("Backup Task List:");

        jPanel1.setLayout(new java.awt.GridLayout(1, 0, 2, 0));

        jCreateBackupTask.setText("New Task");
        jCreateBackupTask.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCreateBackupTaskActionPerformed(evt);
            }
        });
        jPanel1.add(jCreateBackupTask);

        jExecuteSelectedTasks.setText("Run Selected");
        jExecuteSelectedTasks.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jExecuteSelectedTasksActionPerformed(evt);
            }
        });
        jPanel1.add(jExecuteSelectedTasks);

        jExecuteAllTasks.setText("Run All");
        jExecuteAllTasks.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jExecuteAllTasksActionPerformed(evt);
            }
        });
        jPanel1.add(jExecuteAllTasks);

        jValidateTaskList.setText("Validate");
        jValidateTaskList.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jValidateTaskListActionPerformed(evt);
            }
        });
        jPanel1.add(jValidateTaskList);

        jCancelTasks.setForeground(new java.awt.Color(255, 0, 0));
        jCancelTasks.setText("Cancel Run");
        jCancelTasks.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCancelTasksActionPerformed(evt);
            }
        });
        jPanel1.add(jCancelTasks);

        jCleanStatusReport.setForeground(new java.awt.Color(0, 102, 0));
        jCleanStatusReport.setText("Clear Report");
        jCleanStatusReport.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCleanStatusReportActionPerformed(evt);
            }
        });
        jPanel1.add(jCleanStatusReport);

        jRefreshTree.setForeground(new java.awt.Color(0, 0, 255));
        jRefreshTree.setText("Save/Refresh");
        jRefreshTree.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jRefreshTreeActionPerformed(evt);
            }
        });
        jPanel1.add(jRefreshTree);

        jScrollPane2.setCursor(new java.awt.Cursor(java.awt.Cursor.DEFAULT_CURSOR));

        jStatus.setColumns(20);
        jStatus.setLineWrap(true);
        jStatus.setRows(5);
        jStatus.setWrapStyleWord(true);
        jStatus.setAutoscrolls(false);
        jStatus.setBorder(javax.swing.BorderFactory.createEtchedBorder());
        jScrollPane2.setViewportView(jStatus);

        jLogging.setText("Logging");
        jLogging.setHorizontalTextPosition(javax.swing.SwingConstants.LEFT);

        jRunTasksAtSchedule.setSelected(true);
        jRunTasksAtSchedule.setText("Run Tasks At Schedule");
        jRunTasksAtSchedule.setHorizontalTextPosition(javax.swing.SwingConstants.LEFT);
        jRunTasksAtSchedule.addItemListener(new java.awt.event.ItemListener() {
            public void itemStateChanged(java.awt.event.ItemEvent evt) {
                jRunTasksAtScheduleItemStateChanged(evt);
            }
        });

        jScrollPane1.setAutoscrolls(true);

        jScheduledTaskTree.setAutoscrolls(true);
        jScrollPane1.setViewportView(jScheduledTaskTree);

        jTabbedPane1.addTab("Scheduled Tasks", jScrollPane1);

        jScrollPane3.setViewportView(jOneTimeTaskTree);

        jTabbedPane1.addTab("One-Time Tasks", jScrollPane3);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(jScrollPane2))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(10, 10, 10)
                        .addComponent(jLabel1)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(jLogging)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(jRunTasksAtSchedule))
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(0, 75, Short.MAX_VALUE))
                    .addComponent(jTabbedPane1, javax.swing.GroupLayout.Alignment.TRAILING))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel1)
                    .addComponent(jRunTasksAtSchedule)
                    .addComponent(jLogging))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jTabbedPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 322, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jScrollPane2, javax.swing.GroupLayout.DEFAULT_SIZE, 190, Short.MAX_VALUE)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void jCreateBackupTaskActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCreateBackupTaskActionPerformed
        getTaskCreationDialog().setVisible(true);
    }//GEN-LAST:event_jCreateBackupTaskActionPerformed

    private void jExecuteAllTasksActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jExecuteAllTasksActionPerformed
        jExecuteAllTasks.setEnabled(false);
        try{
            (ZcaDocSwingWorkerManager.getSingleton().getZcaDocBackupWorker(retrieveAllZcaDocTaskList(), this)).execute();
        }catch (ZcaDocWorkerNotReadyException ex){
            JOptionPane.showMessageDialog(this, ex.getMessage());
            jExecuteAllTasks.setEnabled(true);
        }
        
    }//GEN-LAST:event_jExecuteAllTasksActionPerformed

    private void jCleanStatusReportActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCleanStatusReportActionPerformed
        jStatus.setText("");
    }//GEN-LAST:event_jCleanStatusReportActionPerformed

    private void formWindowClosing(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_formWindowClosing
        int result = JOptionPane.showConfirmDialog(this, "Shut down with saving the entire task list?");
        if (result == -1){
            return;
        }
        if (result != JOptionPane.CANCEL_OPTION){
            if (result == JOptionPane.YES_OPTION){
                ZcaDocSwingWorkerManager.getSingleton().stopBackupScheduler(this);
                prop.removeZcaDocTaskList(lastIndexOfPersistentTask);
                prop.saveZcaDocTaskList(retrieveAllZcaDocTaskList());
            }
            Runtime.getRuntime().exit(0);
        }
    }//GEN-LAST:event_formWindowClosing

    @Override
    public void swingWorkerDoneEventHappened(final IZcaDocSwingWorkerEvent event) {
        if (SwingUtilities.isEventDispatchThread()){
            swingWorkerDoneEventHappenedHelper(event);
        }else{
            SwingUtilities.invokeLater(new Runnable(){
                @Override
                public void run() {
                    swingWorkerDoneEventHappenedHelper(event);
                }
            });
        }
    }
    private void swingWorkerDoneEventHappenedHelper(final IZcaDocSwingWorkerEvent event) {
        jExecuteSelectedTasks.setEnabled(true);
        jExecuteAllTasks.setEnabled(true);
        jValidateTaskList.setEnabled(true);
    }

    private void jValidateTaskListActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jValidateTaskListActionPerformed
        jValidateTaskList.setEnabled(false);
        try{
            (ZcaDocSwingWorkerManager.getSingleton().getZcaDocValidationWorker(retrieveAllZcaDocTaskList(), this)).execute();
        }catch (ZcaDocWorkerNotReadyException ex){
            JOptionPane.showMessageDialog(this, ex.getMessage());
            jValidateTaskList.setEnabled(true);
        }
    }//GEN-LAST:event_jValidateTaskListActionPerformed

    private void jExecuteSelectedTasksActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jExecuteSelectedTasksActionPerformed
        jExecuteSelectedTasks.setEnabled(false);
        try{
            (ZcaDocSwingWorkerManager.getSingleton().getZcaDocBackupWorker(retrieveSelectedZcaDocTaskList(), this)).execute();
        }catch (ZcaDocWorkerNotReadyException ex){
            JOptionPane.showMessageDialog(this, ex.getMessage());
            jExecuteSelectedTasks.setEnabled(true);
        }
    }//GEN-LAST:event_jExecuteSelectedTasksActionPerformed

    private void jCancelTasksActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCancelTasksActionPerformed
        if (JOptionPane.showConfirmDialog(this, "Cancel current running tasks?") == JOptionPane.YES_OPTION){
            ZcaDocSwingWorkerManager.getSingleton().cancelCurrentWorker();
        }
    }//GEN-LAST:event_jCancelTasksActionPerformed

    private void jRefreshTreeActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jRefreshTreeActionPerformed
        prop.removeZcaDocTaskList(lastIndexOfPersistentTask);
        prop.saveZcaDocTaskList(retrieveAllZcaDocTaskList());
        buildTaskTreeModel();
    }//GEN-LAST:event_jRefreshTreeActionPerformed

    private void jRunTasksAtScheduleItemStateChanged(java.awt.event.ItemEvent evt) {//GEN-FIRST:event_jRunTasksAtScheduleItemStateChanged
        if (evt.getStateChange() == ItemEvent.DESELECTED){
            ZcaDocSwingWorkerManager.getSingleton().stopBackupScheduler(this);
        }
        if (evt.getStateChange() == ItemEvent.SELECTED){
            ZcaDocSwingWorkerManager.getSingleton().startBackupScheduler(this);
        }
    }//GEN-LAST:event_jRunTasksAtScheduleItemStateChanged

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(ZcaDocFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
            ZLogFileHandler.getSingleton().publish(ZLogFileHandler.createSevereLogRecord(ex));
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(ZcaDocFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
            ZLogFileHandler.getSingleton().publish(ZLogFileHandler.createSevereLogRecord(ex));
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(ZcaDocFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
            ZLogFileHandler.getSingleton().publish(ZLogFileHandler.createSevereLogRecord(ex));
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(ZcaDocFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
            ZLogFileHandler.getSingleton().publish(ZLogFileHandler.createSevereLogRecord(ex));
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                new ZcaDocFrame().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jCancelTasks;
    private javax.swing.JButton jCleanStatusReport;
    private javax.swing.JButton jCreateBackupTask;
    private javax.swing.JButton jExecuteAllTasks;
    private javax.swing.JButton jExecuteSelectedTasks;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JCheckBox jLogging;
    private javax.swing.JTree jOneTimeTaskTree;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JButton jRefreshTree;
    private javax.swing.JCheckBox jRunTasksAtSchedule;
    private javax.swing.JTree jScheduledTaskTree;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JTextArea jStatus;
    private javax.swing.JTabbedPane jTabbedPane1;
    private javax.swing.JButton jValidateTaskList;
    // End of variables declaration//GEN-END:variables
    
    private synchronized void expandTaskTree(JTree jTree) {
        for (int i = 0; i < jTree.getRowCount(); i++) {
            jTree.expandPath(jTree.getPathForRow(i));
        }
    }

    @Override
    public synchronized List<ZcaDocTask> retrieveDuedTaskList() {
        ArrayList<ZcaDocTask> aZcaDocTaskList = new ArrayList<ZcaDocTask>();
        int total = scheduledRoot.getChildCount();
        TreeNode treeNode;
        Object task;
        ZcaDocTask aZcaDocTask;
        GregorianCalendar currentTimePoint = new GregorianCalendar();
        GregorianCalendar taskTimePoint;
        for (int i = 0; i < total; i++){
            treeNode = scheduledRoot.getChildAt(i);
            if (treeNode instanceof DefaultMutableTreeNode){
                task = ((DefaultMutableTreeNode)treeNode).getUserObject();
                if (task instanceof ZcaDocTask){
                    aZcaDocTask = (ZcaDocTask)task;
                    taskTimePoint = aZcaDocTask.getDueTimePoint();
                    if ((taskTimePoint != null) && (currentTimePoint.after(taskTimePoint))){
                        aZcaDocTaskList.add(aZcaDocTask);
                    }
                }
            }
        }//for
        return aZcaDocTaskList;
    }

    private synchronized List<ZcaDocTask> retrieveAllZcaDocTaskList() {
        List<ZcaDocTask> aZcaDocTaskList = retrieveAllZcaDocTaskListHelper(scheduledRoot);
        aZcaDocTaskList.addAll(retrieveAllZcaDocTaskListHelper(oneTimeRoot));
        return aZcaDocTaskList;
    }

    private synchronized List<ZcaDocTask> retrieveAllZcaDocTaskListHelper(DefaultMutableTreeNode root) {
        ArrayList<ZcaDocTask> aZcaDocTaskList = new ArrayList<ZcaDocTask>();
        int total = root.getChildCount();
        TreeNode treeNode;
        Object task;
        for (int i = 0; i < total; i++){
            treeNode = root.getChildAt(i);
            if (treeNode instanceof DefaultMutableTreeNode){
                task = ((DefaultMutableTreeNode)treeNode).getUserObject();
                if (task instanceof ZcaDocTask){
                    aZcaDocTaskList.add((ZcaDocTask)task);
                }
            }
        }//for
        return aZcaDocTaskList;
    }

    private synchronized List<ZcaDocTask> retrieveSelectedZcaDocTaskList() {
        List<ZcaDocTask> aZcaDocTaskList = retrieveSelectedZcaDocTaskListHelper(jScheduledTaskTree);
        aZcaDocTaskList.addAll(retrieveSelectedZcaDocTaskListHelper(jOneTimeTaskTree));
        return aZcaDocTaskList;
    }

    private synchronized List<ZcaDocTask> retrieveSelectedZcaDocTaskListHelper(JTree jTree) {
        ArrayList<ZcaDocTask> aZcaDocTaskList = new ArrayList<ZcaDocTask>();
        TreePath[] aSelectedTreePathArray = jTree.getSelectionPaths();
        if (aSelectedTreePathArray != null){
            TreeNode treeNode;
            Object task;
            for (TreePath aTreePath : aSelectedTreePathArray){
                treeNode = (TreeNode)aTreePath.getLastPathComponent();
                if (treeNode instanceof DefaultMutableTreeNode){
                    task = ((DefaultMutableTreeNode)treeNode).getUserObject();
                    if (task instanceof ZcaDocTask){
                        aZcaDocTaskList.add((ZcaDocTask)task);
                    }
                }
            }
        }
        return aZcaDocTaskList;
    }

    synchronized void addZcaDocTask(ZcaDocTask aZcaDocTask) {
        addZcaDocTaskNode(aZcaDocTask);
    }

    private synchronized void addZcaDocTaskNode(ZcaDocTask aZcaDocTask) {
        if (aZcaDocTask != null){
            DefaultMutableTreeNode sourceNode = new DefaultMutableTreeNode(aZcaDocTask);
            DefaultMutableTreeNode backupNode;
            if (aZcaDocTask.isBackupPathSuffixRequired()){
                backupNode = new DefaultMutableTreeNode("Backup to: " + aZcaDocTask.getBackupPath() + "_MMddyyyyHHmmss");
            }else{
                backupNode = new DefaultMutableTreeNode("Backup to: " + aZcaDocTask.getBackupPath());
            }
            DefaultMutableTreeNode overwriteNode;
            if (aZcaDocTask.isOverwriteRequired()){
                overwriteNode = new DefaultMutableTreeNode("Overwrite: YES");
            }else{
                overwriteNode = new DefaultMutableTreeNode("Overwrite: NO");
            }
            DefaultMutableTreeNode runNode;
            DefaultMutableTreeNode scheduleNode;
            GregorianCalendar timePoint = aZcaDocTask.getDueTimePoint();
            if (timePoint == null){
                runNode = new DefaultMutableTreeNode("Next Run: manual mode");
                scheduleNode = new DefaultMutableTreeNode("This task was not Scheduled for any week-day.");
            }else{
                runNode = new DefaultMutableTreeNode("Next Run: automatically run at " 
                        + ZCalendarGlobal.convertToMMddyyyyHHmmss(timePoint, "-", "@", ":"));
                scheduleNode = new DefaultMutableTreeNode("Scheduled at: " + aZcaDocTask.getScheduledDayOfWeekDescription());
            }
            sourceNode.add(backupNode);
            sourceNode.add(overwriteNode);
            sourceNode.add(runNode);
            sourceNode.add(scheduleNode);
            if (timePoint == null){
                oneTimeRoot.add(sourceNode);
                jOneTimeTaskTree.updateUI();
                expandTaskTree(jOneTimeTaskTree);
            }else{
                scheduledRoot.add(sourceNode);
                jScheduledTaskTree.updateUI();
                expandTaskTree(jScheduledTaskTree);
            }
        }
    }
    
    private synchronized void buildTaskTreeModel() {
        prop = new ZcaDocFrameProperties("ZcaDocMaster");
        scheduledRoot = new DefaultMutableTreeNode("Scheduled Task List");
        oneTimeRoot = new DefaultMutableTreeNode("One-Time Task List");
        ZcaDocTask aZcaDocTask;
        lastIndexOfPersistentTask = 0;
        while (true){
            aZcaDocTask = prop.getZcaDocTask(lastIndexOfPersistentTask);
            if (aZcaDocTask == null){
                break;
            }else{
                addZcaDocTaskNode(aZcaDocTask);
            }
            lastIndexOfPersistentTask++;
        }
        
        jScheduledTaskTree.setModel(new DefaultTreeModel(scheduledRoot));
        jOneTimeTaskTree.setModel(new DefaultTreeModel(oneTimeRoot));
    }

    /**
     * This should be invoked in the constructor
     */
    private synchronized void initializeTaskTree() {
        
        buildTaskTreeModel();
        
        initializeTaskTreeShortCutMenu(jScheduledTaskTree);
        initializeTaskTreeShortCutMenu(jOneTimeTaskTree);
    }
    
    private void initializeTaskTreeShortCutMenu(final JTree jTree){
        
        jTree.addMouseListener(new MouseAdapter() {
            @Override
            public void mousePressed(MouseEvent event) {
                if (((event.getModifiers() & InputEvent.BUTTON3_MASK) != 0)
                    && (jTree.getSelectionCount() > 0)) {
                    showMenu(event.getX(), event.getY());
                }
            }

            private void showMenu(int x, int y) {
                JPopupMenu popup = new JPopupMenu();
                JMenuItem mi = new JMenuItem("Delete");
                TreePath path = jTree.getSelectionPath();
                if ((path == null) || (path.getPathCount() != 2)){
                    return;
                }
                Object node = path.getLastPathComponent();
                if (node == jTree.getModel().getRoot()) {
                    mi.setEnabled(false);
                }
                popup.add(mi);
                mi.addActionListener(new ActionListener() {
                    @Override
                    public void actionPerformed(ActionEvent event) {
                        deleteSelectedItems();
                    }
                });
                popup.show(jTree, x, y);
            }

            private void deleteSelectedItems() {
                DefaultMutableTreeNode node;
                DefaultTreeModel model = (DefaultTreeModel) (jTree.getModel());
                TreePath[] paths = jTree.getSelectionPaths();
                for (TreePath path : paths) {
                    if (path.getPathCount() == 2){
                        node = (DefaultMutableTreeNode) (path.getLastPathComponent());
                        model.removeNodeFromParent(node);
                    }
                }
            }
        });
    
    }
    
    @Override
    public void statusMessagingEventHappened(IZcaDocMessageEvent event) {
        String msg = event.getEventMessage();
        jStatus.insert(msg + ZPlatformGlobal.lineSeparator(), jStatus.getDocument().getLength());
        if (event.isLoggingRequired()){
            ZLogFileHandler.getSingleton().publish(ZLogFileHandler.createInfoLogRecord(msg));
        }
        /**
         * clear the status control for performance
         */
        statusMonitor++;
        if (statusMonitor > StatusMonitorThreshold){
            jStatus.setText("");
            statusMonitor = 0;
        }
    }
}
